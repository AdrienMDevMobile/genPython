# coding: utf-8

"""
    Open Food Facts open-prices REST API

    Open Prices API allows you to add product prices

    The version of the OpenAPI document: 0.0.0 (api)
    Contact: contact@openfoodfacts.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date, datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.paginated_proof_full_list import PaginatedProofFullList
from openapi_client.models.patched_price_update_currency import PatchedPriceUpdateCurrency
from openapi_client.models.patched_proof_update import PatchedProofUpdate
from openapi_client.models.price_create_location_osm_type import PriceCreateLocationOsmType
from openapi_client.models.proof_full import ProofFull
from openapi_client.models.proof_update import ProofUpdate
from openapi_client.models.type_enum import TypeEnum

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ProofsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def proofs_destroy(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """proofs_destroy


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_destroy_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def proofs_destroy_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """proofs_destroy


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_destroy_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def proofs_destroy_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """proofs_destroy


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_destroy_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _proofs_destroy_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/proofs/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def proofs_list(
        self,
        created__gte: Optional[datetime] = None,
        created__lte: Optional[datetime] = None,
        currency: Annotated[Optional[StrictStr], Field(description="* `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR")] = None,
        var_date: Optional[date] = None,
        date__gt: Optional[date] = None,
        date__gte: Optional[date] = None,
        date__lt: Optional[date] = None,
        date__lte: Optional[date] = None,
        date__month: Optional[Union[StrictFloat, StrictInt]] = None,
        date__year: Optional[Union[StrictFloat, StrictInt]] = None,
        location_id: Optional[StrictInt] = None,
        location_id__isnull: Optional[StrictBool] = None,
        location_osm_id: Optional[StrictInt] = None,
        location_osm_type: Annotated[Optional[StrictStr], Field(description="* `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        owner: Optional[StrictStr] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        price_count: Optional[StrictInt] = None,
        price_count__gte: Optional[StrictInt] = None,
        price_count__lte: Optional[StrictInt] = None,
        size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="* `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedProofFullList:
        """proofs_list


        :param created__gte:
        :type created__gte: datetime
        :param created__lte:
        :type created__lte: datetime
        :param currency: * `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR
        :type currency: str
        :param var_date:
        :type var_date: date
        :param date__gt:
        :type date__gt: date
        :param date__gte:
        :type date__gte: date
        :param date__lt:
        :type date__lt: date
        :param date__lte:
        :type date__lte: date
        :param date__month:
        :type date__month: float
        :param date__year:
        :type date__year: float
        :param location_id:
        :type location_id: int
        :param location_id__isnull:
        :type location_id__isnull: bool
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type: * `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION
        :type location_osm_type: str
        :param order_by: Which field to use when ordering the results.
        :type order_by: str
        :param owner:
        :type owner: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param price_count:
        :type price_count: int
        :param price_count__gte:
        :type price_count__gte: int
        :param price_count__lte:
        :type price_count__lte: int
        :param size: Number of results to return per page.
        :type size: int
        :param type: * `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_list_serialize(
            created__gte=created__gte,
            created__lte=created__lte,
            currency=currency,
            var_date=var_date,
            date__gt=date__gt,
            date__gte=date__gte,
            date__lt=date__lt,
            date__lte=date__lte,
            date__month=date__month,
            date__year=date__year,
            location_id=location_id,
            location_id__isnull=location_id__isnull,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            order_by=order_by,
            owner=owner,
            page=page,
            price_count=price_count,
            price_count__gte=price_count__gte,
            price_count__lte=price_count__lte,
            size=size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedProofFullList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def proofs_list_with_http_info(
        self,
        created__gte: Optional[datetime] = None,
        created__lte: Optional[datetime] = None,
        currency: Annotated[Optional[StrictStr], Field(description="* `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR")] = None,
        var_date: Optional[date] = None,
        date__gt: Optional[date] = None,
        date__gte: Optional[date] = None,
        date__lt: Optional[date] = None,
        date__lte: Optional[date] = None,
        date__month: Optional[Union[StrictFloat, StrictInt]] = None,
        date__year: Optional[Union[StrictFloat, StrictInt]] = None,
        location_id: Optional[StrictInt] = None,
        location_id__isnull: Optional[StrictBool] = None,
        location_osm_id: Optional[StrictInt] = None,
        location_osm_type: Annotated[Optional[StrictStr], Field(description="* `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        owner: Optional[StrictStr] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        price_count: Optional[StrictInt] = None,
        price_count__gte: Optional[StrictInt] = None,
        price_count__lte: Optional[StrictInt] = None,
        size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="* `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedProofFullList]:
        """proofs_list


        :param created__gte:
        :type created__gte: datetime
        :param created__lte:
        :type created__lte: datetime
        :param currency: * `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR
        :type currency: str
        :param var_date:
        :type var_date: date
        :param date__gt:
        :type date__gt: date
        :param date__gte:
        :type date__gte: date
        :param date__lt:
        :type date__lt: date
        :param date__lte:
        :type date__lte: date
        :param date__month:
        :type date__month: float
        :param date__year:
        :type date__year: float
        :param location_id:
        :type location_id: int
        :param location_id__isnull:
        :type location_id__isnull: bool
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type: * `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION
        :type location_osm_type: str
        :param order_by: Which field to use when ordering the results.
        :type order_by: str
        :param owner:
        :type owner: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param price_count:
        :type price_count: int
        :param price_count__gte:
        :type price_count__gte: int
        :param price_count__lte:
        :type price_count__lte: int
        :param size: Number of results to return per page.
        :type size: int
        :param type: * `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_list_serialize(
            created__gte=created__gte,
            created__lte=created__lte,
            currency=currency,
            var_date=var_date,
            date__gt=date__gt,
            date__gte=date__gte,
            date__lt=date__lt,
            date__lte=date__lte,
            date__month=date__month,
            date__year=date__year,
            location_id=location_id,
            location_id__isnull=location_id__isnull,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            order_by=order_by,
            owner=owner,
            page=page,
            price_count=price_count,
            price_count__gte=price_count__gte,
            price_count__lte=price_count__lte,
            size=size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedProofFullList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def proofs_list_without_preload_content(
        self,
        created__gte: Optional[datetime] = None,
        created__lte: Optional[datetime] = None,
        currency: Annotated[Optional[StrictStr], Field(description="* `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR")] = None,
        var_date: Optional[date] = None,
        date__gt: Optional[date] = None,
        date__gte: Optional[date] = None,
        date__lt: Optional[date] = None,
        date__lte: Optional[date] = None,
        date__month: Optional[Union[StrictFloat, StrictInt]] = None,
        date__year: Optional[Union[StrictFloat, StrictInt]] = None,
        location_id: Optional[StrictInt] = None,
        location_id__isnull: Optional[StrictBool] = None,
        location_osm_id: Optional[StrictInt] = None,
        location_osm_type: Annotated[Optional[StrictStr], Field(description="* `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        owner: Optional[StrictStr] = None,
        page: Annotated[Optional[StrictInt], Field(description="A page number within the paginated result set.")] = None,
        price_count: Optional[StrictInt] = None,
        price_count__gte: Optional[StrictInt] = None,
        price_count__lte: Optional[StrictInt] = None,
        size: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="* `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """proofs_list


        :param created__gte:
        :type created__gte: datetime
        :param created__lte:
        :type created__lte: datetime
        :param currency: * `ADP` - ADP * `AED` - AED * `AFA` - AFA * `AFN` - AFN * `ALK` - ALK * `ALL` - ALL * `AMD` - AMD * `ANG` - ANG * `AOA` - AOA * `AOK` - AOK * `AON` - AON * `AOR` - AOR * `ARA` - ARA * `ARL` - ARL * `ARM` - ARM * `ARP` - ARP * `ARS` - ARS * `ATS` - ATS * `AUD` - AUD * `AWG` - AWG * `AZM` - AZM * `AZN` - AZN * `BAD` - BAD * `BAM` - BAM * `BAN` - BAN * `BBD` - BBD * `BDT` - BDT * `BEC` - BEC * `BEF` - BEF * `BEL` - BEL * `BGL` - BGL * `BGM` - BGM * `BGN` - BGN * `BGO` - BGO * `BHD` - BHD * `BIF` - BIF * `BMD` - BMD * `BND` - BND * `BOB` - BOB * `BOL` - BOL * `BOP` - BOP * `BOV` - BOV * `BRB` - BRB * `BRC` - BRC * `BRE` - BRE * `BRL` - BRL * `BRN` - BRN * `BRR` - BRR * `BRZ` - BRZ * `BSD` - BSD * `BTN` - BTN * `BUK` - BUK * `BWP` - BWP * `BYB` - BYB * `BYN` - BYN * `BYR` - BYR * `BZD` - BZD * `CAD` - CAD * `CDF` - CDF * `CHE` - CHE * `CHF` - CHF * `CHW` - CHW * `CLE` - CLE * `CLF` - CLF * `CLP` - CLP * `CNH` - CNH * `CNX` - CNX * `CNY` - CNY * `COP` - COP * `COU` - COU * `CRC` - CRC * `CSD` - CSD * `CSK` - CSK * `CUC` - CUC * `CUP` - CUP * `CVE` - CVE * `CYP` - CYP * `CZK` - CZK * `DDM` - DDM * `DEM` - DEM * `DJF` - DJF * `DKK` - DKK * `DOP` - DOP * `DZD` - DZD * `ECS` - ECS * `ECV` - ECV * `EEK` - EEK * `EGP` - EGP * `ERN` - ERN * `ESA` - ESA * `ESB` - ESB * `ESP` - ESP * `ETB` - ETB * `EUR` - EUR * `FIM` - FIM * `FJD` - FJD * `FKP` - FKP * `FRF` - FRF * `GBP` - GBP * `GEK` - GEK * `GEL` - GEL * `GHC` - GHC * `GHS` - GHS * `GIP` - GIP * `GMD` - GMD * `GNF` - GNF * `GNS` - GNS * `GQE` - GQE * `GRD` - GRD * `GTQ` - GTQ * `GWE` - GWE * `GWP` - GWP * `GYD` - GYD * `HKD` - HKD * `HNL` - HNL * `HRD` - HRD * `HRK` - HRK * `HTG` - HTG * `HUF` - HUF * `IDR` - IDR * `IEP` - IEP * `ILP` - ILP * `ILR` - ILR * `ILS` - ILS * `INR` - INR * `IQD` - IQD * `IRR` - IRR * `ISJ` - ISJ * `ISK` - ISK * `ITL` - ITL * `JMD` - JMD * `JOD` - JOD * `JPY` - JPY * `KES` - KES * `KGS` - KGS * `KHR` - KHR * `KMF` - KMF * `KPW` - KPW * `KRH` - KRH * `KRO` - KRO * `KRW` - KRW * `KWD` - KWD * `KYD` - KYD * `KZT` - KZT * `LAK` - LAK * `LBP` - LBP * `LKR` - LKR * `LRD` - LRD * `LSL` - LSL * `LTL` - LTL * `LTT` - LTT * `LUC` - LUC * `LUF` - LUF * `LUL` - LUL * `LVL` - LVL * `LVR` - LVR * `LYD` - LYD * `MAD` - MAD * `MAF` - MAF * `MCF` - MCF * `MDC` - MDC * `MDL` - MDL * `MGA` - MGA * `MGF` - MGF * `MKD` - MKD * `MKN` - MKN * `MLF` - MLF * `MMK` - MMK * `MNT` - MNT * `MOP` - MOP * `MRO` - MRO * `MRU` - MRU * `MTL` - MTL * `MTP` - MTP * `MUR` - MUR * `MVP` - MVP * `MVR` - MVR * `MWK` - MWK * `MXN` - MXN * `MXP` - MXP * `MXV` - MXV * `MYR` - MYR * `MZE` - MZE * `MZM` - MZM * `MZN` - MZN * `NAD` - NAD * `NGN` - NGN * `NIC` - NIC * `NIO` - NIO * `NLG` - NLG * `NOK` - NOK * `NPR` - NPR * `NZD` - NZD * `OMR` - OMR * `PAB` - PAB * `PEI` - PEI * `PEN` - PEN * `PES` - PES * `PGK` - PGK * `PHP` - PHP * `PKR` - PKR * `PLN` - PLN * `PLZ` - PLZ * `PTE` - PTE * `PYG` - PYG * `QAR` - QAR * `RHD` - RHD * `ROL` - ROL * `RON` - RON * `RSD` - RSD * `RUB` - RUB * `RUR` - RUR * `RWF` - RWF * `SAR` - SAR * `SBD` - SBD * `SCR` - SCR * `SDD` - SDD * `SDG` - SDG * `SDP` - SDP * `SEK` - SEK * `SGD` - SGD * `SHP` - SHP * `SIT` - SIT * `SKK` - SKK * `SLE` - SLE * `SLL` - SLL * `SOS` - SOS * `SRD` - SRD * `SRG` - SRG * `SSP` - SSP * `STD` - STD * `STN` - STN * `SUR` - SUR * `SVC` - SVC * `SYP` - SYP * `SZL` - SZL * `THB` - THB * `TJR` - TJR * `TJS` - TJS * `TMM` - TMM * `TMT` - TMT * `TND` - TND * `TOP` - TOP * `TPE` - TPE * `TRL` - TRL * `TRY` - TRY * `TTD` - TTD * `TWD` - TWD * `TZS` - TZS * `UAH` - UAH * `UAK` - UAK * `UGS` - UGS * `UGX` - UGX * `USD` - USD * `USN` - USN * `USS` - USS * `UYI` - UYI * `UYP` - UYP * `UYU` - UYU * `UYW` - UYW * `UZS` - UZS * `VEB` - VEB * `VED` - VED * `VEF` - VEF * `VES` - VES * `VND` - VND * `VNN` - VNN * `VUV` - VUV * `WST` - WST * `XAF` - XAF * `XAG` - XAG * `XAU` - XAU * `XBA` - XBA * `XBB` - XBB * `XBC` - XBC * `XBD` - XBD * `XCD` - XCD * `XDR` - XDR * `XEU` - XEU * `XFO` - XFO * `XFU` - XFU * `XOF` - XOF * `XPD` - XPD * `XPF` - XPF * `XPT` - XPT * `XRE` - XRE * `XSU` - XSU * `XTS` - XTS * `XUA` - XUA * `XXX` - XXX * `YDD` - YDD * `YER` - YER * `YUD` - YUD * `YUM` - YUM * `YUN` - YUN * `YUR` - YUR * `ZAL` - ZAL * `ZAR` - ZAR * `ZMK` - ZMK * `ZMW` - ZMW * `ZRN` - ZRN * `ZRZ` - ZRZ * `ZWD` - ZWD * `ZWL` - ZWL * `ZWR` - ZWR
        :type currency: str
        :param var_date:
        :type var_date: date
        :param date__gt:
        :type date__gt: date
        :param date__gte:
        :type date__gte: date
        :param date__lt:
        :type date__lt: date
        :param date__lte:
        :type date__lte: date
        :param date__month:
        :type date__month: float
        :param date__year:
        :type date__year: float
        :param location_id:
        :type location_id: int
        :param location_id__isnull:
        :type location_id__isnull: bool
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type: * `NODE` - NODE * `WAY` - WAY * `RELATION` - RELATION
        :type location_osm_type: str
        :param order_by: Which field to use when ordering the results.
        :type order_by: str
        :param owner:
        :type owner: str
        :param page: A page number within the paginated result set.
        :type page: int
        :param price_count:
        :type price_count: int
        :param price_count__gte:
        :type price_count__gte: int
        :param price_count__lte:
        :type price_count__lte: int
        :param size: Number of results to return per page.
        :type size: int
        :param type: * `PRICE_TAG` - PRICE_TAG * `RECEIPT` - RECEIPT * `GDPR_REQUEST` - GDPR_REQUEST * `SHOP_IMPORT` - SHOP_IMPORT
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_list_serialize(
            created__gte=created__gte,
            created__lte=created__lte,
            currency=currency,
            var_date=var_date,
            date__gt=date__gt,
            date__gte=date__gte,
            date__lt=date__lt,
            date__lte=date__lte,
            date__month=date__month,
            date__year=date__year,
            location_id=location_id,
            location_id__isnull=location_id__isnull,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            order_by=order_by,
            owner=owner,
            page=page,
            price_count=price_count,
            price_count__gte=price_count__gte,
            price_count__lte=price_count__lte,
            size=size,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedProofFullList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _proofs_list_serialize(
        self,
        created__gte,
        created__lte,
        currency,
        var_date,
        date__gt,
        date__gte,
        date__lt,
        date__lte,
        date__month,
        date__year,
        location_id,
        location_id__isnull,
        location_osm_id,
        location_osm_type,
        order_by,
        owner,
        page,
        price_count,
        price_count__gte,
        price_count__lte,
        size,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if created__gte is not None:
            if isinstance(created__gte, datetime):
                _query_params.append(
                    (
                        'created__gte',
                        created__gte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created__gte', created__gte))
            
        if created__lte is not None:
            if isinstance(created__lte, datetime):
                _query_params.append(
                    (
                        'created__lte',
                        created__lte.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('created__lte', created__lte))
            
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(
                    (
                        'date',
                        var_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date', var_date))
            
        if date__gt is not None:
            if isinstance(date__gt, date):
                _query_params.append(
                    (
                        'date__gt',
                        date__gt.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date__gt', date__gt))
            
        if date__gte is not None:
            if isinstance(date__gte, date):
                _query_params.append(
                    (
                        'date__gte',
                        date__gte.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date__gte', date__gte))
            
        if date__lt is not None:
            if isinstance(date__lt, date):
                _query_params.append(
                    (
                        'date__lt',
                        date__lt.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date__lt', date__lt))
            
        if date__lte is not None:
            if isinstance(date__lte, date):
                _query_params.append(
                    (
                        'date__lte',
                        date__lte.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date__lte', date__lte))
            
        if date__month is not None:
            
            _query_params.append(('date__month', date__month))
            
        if date__year is not None:
            
            _query_params.append(('date__year', date__year))
            
        if location_id is not None:
            
            _query_params.append(('location_id', location_id))
            
        if location_id__isnull is not None:
            
            _query_params.append(('location_id__isnull', location_id__isnull))
            
        if location_osm_id is not None:
            
            _query_params.append(('location_osm_id', location_osm_id))
            
        if location_osm_type is not None:
            
            _query_params.append(('location_osm_type', location_osm_type))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if owner is not None:
            
            _query_params.append(('owner', owner))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if price_count is not None:
            
            _query_params.append(('price_count', price_count))
            
        if price_count__gte is not None:
            
            _query_params.append(('price_count__gte', price_count__gte))
            
        if price_count__lte is not None:
            
            _query_params.append(('price_count__lte', price_count__lte))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/proofs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def proofs_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        patched_proof_update: Optional[PatchedProofUpdate] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProofUpdate:
        """proofs_partial_update


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param patched_proof_update:
        :type patched_proof_update: PatchedProofUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_partial_update_serialize(
            id=id,
            patched_proof_update=patched_proof_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofUpdate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def proofs_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        patched_proof_update: Optional[PatchedProofUpdate] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProofUpdate]:
        """proofs_partial_update


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param patched_proof_update:
        :type patched_proof_update: PatchedProofUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_partial_update_serialize(
            id=id,
            patched_proof_update=patched_proof_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofUpdate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def proofs_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        patched_proof_update: Optional[PatchedProofUpdate] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """proofs_partial_update


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param patched_proof_update:
        :type patched_proof_update: PatchedProofUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_partial_update_serialize(
            id=id,
            patched_proof_update=patched_proof_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofUpdate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _proofs_partial_update_serialize(
        self,
        id,
        patched_proof_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_proof_update is not None:
            _body_params = patched_proof_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v1/proofs/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def proofs_retrieve(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProofFull:
        """proofs_retrieve


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_retrieve_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def proofs_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProofFull]:
        """proofs_retrieve


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_retrieve_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def proofs_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this Proof.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """proofs_retrieve


        :param id: A unique integer value identifying this Proof. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_retrieve_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _proofs_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/proofs/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def proofs_upload_create(
        self,
        file: StrictStr,
        type: TypeEnum,
        currency: Optional[PatchedPriceUpdateCurrency] = None,
        var_date: Optional[date] = None,
        location_osm_id: Optional[Annotated[int, Field(le=9223372036854775807, strict=True, ge=0)]] = None,
        location_osm_type: Optional[PriceCreateLocationOsmType] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProofFull:
        """proofs_upload_create


        :param file: (required)
        :type file: str
        :param type: (required)
        :type type: TypeEnum
        :param currency:
        :type currency: PatchedPriceUpdateCurrency
        :param var_date:
        :type var_date: date
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type:
        :type location_osm_type: PriceCreateLocationOsmType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_upload_create_serialize(
            file=file,
            type=type,
            currency=currency,
            var_date=var_date,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def proofs_upload_create_with_http_info(
        self,
        file: StrictStr,
        type: TypeEnum,
        currency: Optional[PatchedPriceUpdateCurrency] = None,
        var_date: Optional[date] = None,
        location_osm_id: Optional[Annotated[int, Field(le=9223372036854775807, strict=True, ge=0)]] = None,
        location_osm_type: Optional[PriceCreateLocationOsmType] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProofFull]:
        """proofs_upload_create


        :param file: (required)
        :type file: str
        :param type: (required)
        :type type: TypeEnum
        :param currency:
        :type currency: PatchedPriceUpdateCurrency
        :param var_date:
        :type var_date: date
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type:
        :type location_osm_type: PriceCreateLocationOsmType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_upload_create_serialize(
            file=file,
            type=type,
            currency=currency,
            var_date=var_date,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def proofs_upload_create_without_preload_content(
        self,
        file: StrictStr,
        type: TypeEnum,
        currency: Optional[PatchedPriceUpdateCurrency] = None,
        var_date: Optional[date] = None,
        location_osm_id: Optional[Annotated[int, Field(le=9223372036854775807, strict=True, ge=0)]] = None,
        location_osm_type: Optional[PriceCreateLocationOsmType] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """proofs_upload_create


        :param file: (required)
        :type file: str
        :param type: (required)
        :type type: TypeEnum
        :param currency:
        :type currency: PatchedPriceUpdateCurrency
        :param var_date:
        :type var_date: date
        :param location_osm_id:
        :type location_osm_id: int
        :param location_osm_type:
        :type location_osm_type: PriceCreateLocationOsmType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._proofs_upload_create_serialize(
            file=file,
            type=type,
            currency=currency,
            var_date=var_date,
            location_osm_id=location_osm_id,
            location_osm_type=location_osm_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProofFull",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _proofs_upload_create_serialize(
        self,
        file,
        type,
        currency,
        var_date,
        location_osm_id,
        location_osm_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if file is not None:
            _form_params.append(('file', file))
        if type is not None:
            _form_params.append(('type', type))
        if currency is not None:
            _form_params.append(('currency', currency))
        if var_date is not None:
            _form_params.append(('date', var_date))
        if location_osm_id is not None:
            _form_params.append(('location_osm_id', location_osm_id))
        if location_osm_type is not None:
            _form_params.append(('location_osm_type', location_osm_type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/proofs/upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


